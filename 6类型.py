import osimport sysimport timefrom datetime import datetimefrom colorama import init, Fore# 初始化 coloramainit(autoreset=True)# 确保清除屏幕的命令在不同的操作系统上都能工作def clear_screen():    os.system("cls" if os.name == "nt" else "clear")# 打印带有打字效果的文本def typing_effect(text, delay=0.03):    for char in text:        sys.stdout.write(char)        sys.stdout.flush()        time.sleep(delay)    print()# 打印带有加载效果的文本def loading_effect(message, duration=1.5):    print(message, end="")    for _ in range(5):        print(".", end="", flush=True)        time.sleep(duration / 5)    print()# 显示头部标题和信息def show_header():    clear_screen()    print("""""")    time.sleep(0.6)    typing_effect("砚冰4588")    loading_effect("启动中…7578")# 将十进制数转换为倒序的8位十六进制字符串def DEC_to_HEX(decimal_number):    try:        hex_number = format(int(decimal_number), '08X')    except ValueError:        print(f"无效的十进制数: {decimal_number}")        return None    hex_array = [hex_number[i:i + 2] for i in range(0, len(hex_number), 2)]    reversed_hex_array = hex_array[::-1]    reversed_hex_number = ''.join(reversed_hex_array)    return reversed_hex_number# 在文件中交换两段十六进制数据def modify_file_hex(file_path, A, B, hex_start, hex_end):    try:        search_seq1 = bytes.fromhex(A)        search_seq2 = bytes.fromhex(B)        hex_to_find_start = bytes.fromhex(hex_start)        hex_to_find_end = bytes.fromhex(hex_end)    except ValueError as e:        print(f"无效的十六进制字符串: {e}")        return False    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return False    search_index1 = file_contents.find(search_seq1)    search_index2 = file_contents.find(search_seq2)    if search_index1 == -1 or search_index2 == -1:        print(f"文件 {file_path} 未找到指定的搜索序列。")        return False    start_index1 = find_hex_reverse(file_contents, hex_to_find_start, search_index1)    end_index1 = find_hex(file_contents, hex_to_find_end, start_index1 + len(hex_to_find_start), search_index1)        start_index2 = find_hex_reverse(file_contents, hex_to_find_start, search_index2)    end_index2 = find_hex(file_contents, hex_to_find_end, start_index2 + len(hex_to_find_start), search_index2)    if any(idx == -1 for idx in [start_index1, end_index1, start_index2, end_index2]):        print(f"文件 {file_path} 未找到十六进制数。")        return False        data_to_replace1 = file_contents[start_index1 + len(hex_to_find_start):end_index1]    data_to_replace2 = file_contents[start_index2 + len(hex_to_find_start):end_index2]    new_contents = bytearray(file_contents)    new_contents[start_index1 + len(hex_to_find_start):end_index1] = data_to_replace2    new_contents[start_index2 + len(hex_to_find_start):end_index2] = data_to_replace1    try:        with open(file_path, "wb") as file:            file.write(new_contents)    except Exception as e:        print(f"写入文件时出错: {e}")        return False    print(f"文件 {file_path} 已编辑")    return True# 向后查找十六进制数def find_hex(data, hex_to_find, start, end):    return data.find(hex_to_find, start, end)# 向前查找十六进制数def find_hex_reverse(data, hex_to_find, start):    return data.rfind(hex_to_find, 0, start)# 自动识别特征码函数def auto_detect_feature_codes_hall_action(file_path):    target_hex = "F09B2100"    target_bytes = bytes.fromhex(target_hex)    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return None, None    target_pos = file_contents.find(target_bytes)    if target_pos == -1:        print(f"文件 {file_path} 中未找到目标十六进制值 {target_hex}")        return None, None    feature_code1 = file_contents[target_pos - 186:target_pos - 182].hex().upper() if target_pos - 186 >= 0 else None    feature_code2 = file_contents[target_pos - 170:target_pos - 166].hex().upper() if target_pos - 170 >= 0 else None    return feature_code1, feature_code2def auto_detect_feature_codes_subway(file_path):    target_hex = "74207C3A"    target_bytes = bytes.fromhex(target_hex)    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return None, None    target_pos = file_contents.find(target_bytes)    if target_pos == -1:        print(f"文件 {file_path} 中未找到目标十六进制值 {target_hex}")        return None, None    feature_code1 = file_contents[target_pos - 185:target_pos - 181].hex().upper() if target_pos - 185 >= 0 else None    feature_code2 = file_contents[target_pos - 169:target_pos - 165].hex().upper() if target_pos - 169 >= 0 else None    return feature_code1, feature_code2def auto_detect_feature_codes_title(file_path):    target_hex = "BE582F00"    target_bytes = bytes.fromhex(target_hex)    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return None, None    target_pos = file_contents.find(target_bytes)    if target_pos == -1:        print(f"文件 {file_path} 中未找到目标十六进制值 {target_hex}")        return None, None    feature_code1 = file_contents[target_pos - 436:target_pos - 432].hex().upper() if target_pos - 436 >= 0 else None    feature_code2 = file_contents[target_pos - 420:target_pos - 416].hex().upper() if target_pos - 420 >= 0 else None    return feature_code1, feature_code2def auto_detect_feature_codes_warrior(file_path):    target_hex = "538C1E00"    target_bytes = bytes.fromhex(target_hex)    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return None, None    target_pos = file_contents.find(target_bytes)    if target_pos == -1:        print(f"文件 {file_path} 中未找到目标十六进制值 {target_hex}")        return None, None    feature_code1 = file_contents[target_pos - 188:target_pos - 184].hex().upper() if target_pos - 188 >= 0 else None    feature_code2 = file_contents[target_pos - 172:target_pos - 168].hex().upper() if target_pos - 172 >= 0 else None    return feature_code1, feature_code2def auto_detect_feature_codes_elimination(file_path):    target_hex = "6AC70D00"    target_bytes = bytes.fromhex(target_hex)    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return None, None    target_pos = file_contents.find(target_bytes)    if target_pos == -1:        print(f"文件 {file_path} 中未找到目标十六进制值 {target_hex}")        return None, None    feature_code1 = file_contents[target_pos - 100:target_pos - 96].hex().upper() if target_pos - 100 >= 0 else None    feature_code2 = file_contents[target_pos - 84:target_pos - 80].hex().upper() if target_pos - 84 >= 0 else None    return feature_code1, feature_code2def auto_detect_feature_codes_entry(file_path):    target_hex = "0B270600"    target_bytes = bytes.fromhex(target_hex)    try:        with open(file_path, "rb") as file:            file_contents = file.read()    except FileNotFoundError:        print(f"文件未找到: {file_path}")        return None, None    target_pos = file_contents.find(target_bytes)    if target_pos == -1:        print(f"文件 {file_path} 中未找到目标十六进制值 {target_hex}")        return None, None    feature_code1 = file_contents[target_pos - 76:target_pos - 72].hex().upper() if target_pos - 76 >= 0 else None    feature_code2 = file_contents[target_pos - 60:target_pos - 56].hex().upper() if target_pos - 60 >= 0 else None    return feature_code1, feature_code2# 管理文件路径的类class FilePathManager:    @staticmethod    def get_dat_files_dir(option):        dirs = {            1: "/data/user/0/com.termux/files/home/砚冰云端制作区/dat美化/dat打包",            2: "/data/user/0/com.termux/files/home/砚冰云端制作区/dat美化/dat打包",            3: "/data/user/0/com.termux/files/home/砚冰云端制作区/dat美化/dat打包",            4: "/data/user/0/com.termux/files/home/砚冰云端制作区/dat美化/dat打包",            5: "/data/user/0/com.termux/files/home/砚冰云端制作区/dat美化/dat打包",            6: "/data/user/0/com.termux/files/home/砚冰云端制作区/dat美化/dat打包"        }        return dirs.get(option, None)    @staticmethod    def get_config_files_dir():        return "/data/user/0/com.termux/files/home/砚冰云端制作区/＞配置放这里＜/"# 让用户选择.dat文件def select_dat_file(dat_files_dir):    if not dat_files_dir:        return None    print("可选的.dat文件:")    try:        dat_files = [f for f in os.listdir(dat_files_dir) if os.path.isfile(os.path.join(dat_files_dir, f)) and f.endswith('.dat')]    except Exception as e:        print(f"读取目录时出错: {e}")        return None    if not dat_files:        print(f"目录 {dat_files_dir} 中没有找到.dat文件")        return None    for i, file in enumerate(dat_files):        print(f"{i}: {file}")    while True:        try:            selected_dat_index = int(input("请选择一个.dat文件（输入数字）: "))            if 0 <= selected_dat_index < len(dat_files):                return os.path.join(dat_files_dir, dat_files[selected_dat_index])            else:                print("请输入有效的序号！")        except ValueError:            print("请输入有效的数字！")# 让用户选择配置文件def select_config_file(config_files_dir):    print("可选的配置文件:")    try:        config_files = [f for f in os.listdir(config_files_dir) if os.path.isfile(os.path.join(config_files_dir, f))]    except Exception as e:        print(f"读取目录时出错: {e}")        return None    if not config_files:        print(f"目录 {config_files_dir} 中没有找到配置文件")        return None    for i, file in enumerate(config_files):        print(f"{i}: {file}")    while True:        try:            selected_config_index = int(input("请选择一个配置文件（输入数字）: "))            if 0 <= selected_config_index < len(config_files):                return os.path.join(config_files_dir, config_files[selected_config_index])            else:                print("请输入有效的序号！")        except ValueError:            print("请输入有效的数字！")# 【优化后的函数】读取并解析配置文件def read_array_from_file(file_path):    array = []    try:        with open(file_path, 'r') as file:            for line in file:                line = line.strip()                if not line or line.startswith('#'):                    continue                # 移除行内注释                if '#' in line:                    line = line.split('#')[0].strip()                # 尝试解析两种格式                try:                    # 格式1: `123 456` (空格分隔)                    parts = line.split()                    if len(parts) == 2:                        num1 = int(parts[0])                        num2 = int(parts[1])                        array.append([num1, num2])                        continue                except ValueError:                    pass                try:                    # 格式2: `[123, 456]` (Python列表格式)                    if line.startswith('[') and line.endswith(']'):                        # 安全地评估表达式                        line = line.replace('[', '').replace(']', '')                        parts = line.split(',')                        if len(parts) == 2:                            num1 = int(parts[0].strip())                            num2 = int(parts[1].strip())                            array.append([num1, num2])                            continue                except (ValueError, SyntaxError):                    pass                                print(f"警告: 跳过无法解析的行: {line}")    except Exception as e:        print(f"读取或解析数组文件时出错: {e}")        return None        return array# 处理文件def process_file(file_path, array, hex_start, hex_end):    print(f"\n开始处理文件: {file_path}")    print(f"将使用特征码: {hex_start} 和 {hex_end}\n")        for i, (dec1, dec2) in enumerate(array):        print(f"正在处理第 {i+1} 组: {dec1} -> {dec2}")        A = DEC_to_HEX(dec1)        B = DEC_to_HEX(dec2)                if A is None or B is None:            print(f"跳过无效的十进制数对: {dec1}, {dec2}")            continue                success = modify_file_hex(file_path, A, B, hex_start, hex_end)        if success:            print(f"处理第 {i+1} 组代码成功。")        else:            print(f"处理第 {i+1} 组代码失败。")                print("------------------------------------------------------")# 让用户选择自动识别还是手动输入特征码def get_feature_codes(selected_option, file_path):    print("\n请选择特征码获取方式:")    print("1. 自动识别特征码")    print("2. 手动输入特征码")        while True:        try:            choice = int(input("请输入选项数字(1或2): "))            if choice in (1, 2):                break            else:                print("请输入1或2！")        except ValueError:            print("请输入有效的数字！")        feature_code1, feature_code2 = None, None    if choice == 1:        print("\n正在自动识别特征码...")        auto_detect_functions = {            1: auto_detect_feature_codes_hall_action,            2: auto_detect_feature_codes_subway,            3: auto_detect_feature_codes_title,            4: auto_detect_feature_codes_warrior,            5: auto_detect_feature_codes_elimination,            6: auto_detect_feature_codes_entry        }        detect_function = auto_detect_functions.get(selected_option)        if detect_function:            feature_code1, feature_code2 = detect_function(file_path)            if feature_code1 and feature_code2:                print(f"\n自动识别结果:")                print(f"第一个特征码: {feature_code1}")                print(f"第二个特征码: {feature_code2}")                confirm = input("\n是否使用这些特征码? (y/n): ").lower()                if confirm == 'y':                    return feature_code1, feature_code2                else:                    print("将改为手动输入特征码...")            else:                print("自动识别失败，将改为手动输入特征码...")        print("\n请输入特征码(16进制，8位，不带空格，例如: 12345678)")    while True:        feature_code1 = input("请输入第一个特征码: ").strip().upper()        feature_code2 = input("请输入第二个特征码: ").strip().upper()                if len(feature_code1) != 8 or len(feature_code2) != 8:            print("特征码必须是8位16进制数！")            continue        try:            bytes.fromhex(feature_code1)            bytes.fromhex(feature_code2)            return feature_code1, feature_code2        except ValueError:            print("输入的特征码不是有效的16进制格式！请重新输入。")# 主函数def main():    show_header()    current_time = datetime.now().strftime('%Y-%m-%d %H:%M')    print(f"""\033[93m█░░█░█▀█░███░███░███░█░░██░░█▀█░░█░░█░█░█░█░█░░▀▀░░██▀░░▀░░▀▀▀░▀▀▀░▀▀▀▀░-----------------------------------公告：    每一个不曾起舞的日子，都是对生命的辜负。今天的你，比昨天更接近梦想！状态_付费  永久卡：不要\033[9m999r\033[0m\033[93m只要15.88┏══════════════════════════════════════┓┃作者:砚冰ʸᵇ┃执行时间:{current_time} ┃╚══════════════════════════════════════╝┏══════════════════════════════════════┓┃[1] 大厅动作                          ┃┃══════════════════════════════════════┃┃[2] 地铁传世武器                      ┃┃══════════════════════════════════════┃┃[3] 称号美化                          ┃┃══════════════════════════════════════┃┃[4] 头像框美化                        ┃┃══════════════════════════════════════┃┃[5] 淘汰播报美化                      ┃┃══════════════════════════════════════┃┃[6] 商城入场美化                      ┃┃══════════════════════════════════════┃┃[7] 返回上一级                        ┃       ╚══════════════════════════════════════╝    """)    while True:        try:            selected_option = int(input("请输入选项数字: "))            if 1 <= selected_option <= 7:                break            else:                print("请输入有效的选项！")        except ValueError:            print("请输入有效的数字！")    if selected_option == 7:        loading_effect("正在执行中")        print("感谢使用！")        input("回车继续...")        return    dat_files_dir = FilePathManager.get_dat_files_dir(selected_option)    if not dat_files_dir:        print("无效的选项！")        return    file_path = select_dat_file(dat_files_dir)    if not file_path:        return        feature_code1, feature_code2 = get_feature_codes(selected_option, file_path)    if not feature_code1 or not feature_code2:        print("获取特征码失败，程序退出。")        return        print(f"\n将使用的第一个特征码: {feature_code1}")    print(f"将使用的第二个特征码: {feature_code2}")    time.sleep(1)        config_files_dir = FilePathManager.get_config_files_dir()    array_file_path = select_config_file(config_files_dir)    if not array_file_path:        return    array = read_array_from_file(array_file_path)    if not array:        print("配置文件为空或无法解析。")        return        process_file(file_path, array, feature_code1, feature_code2)if __name__ == "__main__":    main()    input("回车继续...")